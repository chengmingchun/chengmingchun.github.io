<!DOCTYPE html>
<html lang="zh-CN"><head>
    <title>神威空间</title>
    <script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="format-detection" content="telephone=no" />
    <meta name="theme-color" content="#000084" />
    <link rel="icon" href="../favicon.ico">
    <link rel="canonical" href="">
    
    
</head>
<body>
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="navbar-inner">
        <div class="container">
            <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse"></button>
            <a class="brand" href="">神威空间</a>
            <div class="nav-collapse collapse">
                <ul class="nav">
                    
                    
                        
                            <li>
                                <a href="../about/">
                                    
                                    <span>个人简历</span>
                                </a>
                            </li>
                        
                    
                        
                            <li>
                                <a href="../post/">
                                    
                                    <span>文章</span>
                                </a>
                            </li>
                        
                    
                        
                            <li>
                                <a href="../post/">
                                    
                                    <span>demo</span>
                                </a>
                            </li>
                        
                    
                        
                            <li>
                                <a href="../post/">
                                    
                                    <span>照片墙</span>
                                </a>
                            </li>
                        
                    
                </ul>
            </div>
        </div>
    </div>
</nav><div id="content" class="container">

<div class="row-fluid navmargin" style="background-color: white; padding:2%;color: black;">
    <div class="page-header">
        <h1>鱼群算法求解顺丰比赛问题 - Fri, Aug 28, 2020</h1>
    </div>
    <p class="lead" style="color: #000;">欢迎阅读鱼群算法求解顺丰比赛问题</p>
    <p>本部分采取启发式算法进行求解探索，以期可以应对大规模问题的求解。最终得到较优解为26094，其中空驶路成为3916，最长行驶时间为41.08小时。在本部分中，主要采取禁忌搜索寻找初始可行解，再利用人工鱼群算法进行进一步的优化。</p>
<p>这是参加比赛时进行的算法设计，通过领域搜索和对鱼群算法框架的改动完成了集合覆盖类问题的求解。算法设计的重点在于编码设计，适应度函数设计和相应的算法动作的改造。鱼群算法因为杂揉了遗传算法的优胜劣汰、粒子群算法局部全域相结合以及领域搜索的随机性，具有较好的效果。</p>
<h2 id="算法设计">算法设计</h2>
<h3 id="编码设计">编码设计</h3>
<p>可以直接用实数编码的方式，即用数字代表车辆序号，比如4号任务数字为20，即20号车执行4号任务。同时为了加快算法的运行速度，引入顺序概念。比如4号任务的数字为20.4555代表20号车以0.4555的顺序执行该任务。</p>
<p>如果有一个原始码[5.432, 5.211, 4.221, 3.265, 3.710 &hellip;&hellip;]，解码后得到：</p>
<table>
<thead>
<tr>
<th>车辆序号</th>
<th>执行任务</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>2-1</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td>4-5</td>
</tr>
</tbody>
</table>
<p>判断可行与否可以通过解码后将各车任务依次放入原数据中做对比，判断是否违反约束，在算法中，用w1,w3,w4分别表示违反时间约束，w3表示是否违反段数约束，w4表示是否违反运行时间约束。其中时间约束不仅判断当前是否可运行，同时对加入空驶和任务放入第二天是否可行都进行了判断。而地点衔接约束，可以通过空驶转换为前述三种约束。在判断函数中用w2记录空驶距离。（函数cando.m）</p>
<p>适应度函数则直接按照给解码后方案对应定数据表中的距离加上违反约束带来的惩罚和空驶距离来表示，当方案没有违反约束时，该适应度函数表示的是优化得到的距离。(函数foo.m)</p>
<h3 id="初始解构造">初始解构造</h3>
<p>初始解可以通过随机数的方式构造，这种方法的优点在于简单快捷，缺点在于会出现过多的不可行解，影响算法的精确度和运行速度；或者采取其他方法构造初始可行解群。这里简单介绍一下初始可行解的构造方法：</p>
<p><!-- raw HTML omitted --></p>
<p>可以通过随机打乱1到341作为可行解种子（即每辆车只跑一个任务），然后对该解的每一部分进行随机扰动（由于编码的性质，可以很容易的证明车辆数会少于341，因此只减去一个随机因子便可以得到新解），如果得到的解更优的话，则保存新解。为了加强算法的搜索性能，引入了禁忌表作为辅助搜索策略，即更新解后会更新禁忌表相应的位置，保持该解一段时间。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-matlab" data-lang="matlab">pop = randperm(<span style="color:#ae81ff">341</span>); <span style="color:#f92672">//</span> 随机打乱<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">341</span>
best = inf;
<span style="color:#66d9ef">for</span>(i =<span style="color:#ae81ff">1</span>; i<span style="color:#f92672">&lt;</span>iter_time; i<span style="color:#f92672">++</span> ){
  copy = pop;
  <span style="color:#66d9ef">if</span> (tabu(i) <span style="color:#f92672">&lt;</span> spec){
    pop(i) = pop(i) <span style="color:#f92672">-</span> pop(i)rand();
  	<span style="color:#66d9ef">if</span> (evaluate(pop) <span style="color:#f92672">&lt;</span> best)<span style="color:#f92672">&amp;&amp;</span>(cando(pop)){ 
      best_pop = pop;
			best = evaluate(pop);
      tabu(i) = tl; <span style="color:#f92672">//</span>更新禁忌表，tl为禁忌步长
		<span style="color:#66d9ef">else</span>
      pop = copy;  <span style="color:#f92672">//</span>如果不符合约束或者没有更优则回退
    }
  }
  <span style="color:#f92672">//</span>更新禁忌表
  <span style="color:#66d9ef">for</span>(j = <span style="color:#ae81ff">1</span>; j<span style="color:#f92672">&lt;</span>length(tabu); j<span style="color:#f92672">++</span>){
    <span style="color:#66d9ef">if</span> (tabu(j) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
      tabu(j)<span style="color:#f92672">--</span>；
  }
}

 
</code></pre></div><h2 id="鱼群算法">鱼群算法</h2>
<p>鱼群算法是一种现代启发式智能搜索算法，具有现代优化算法的很多特征。通过模拟鱼群的觅食、聚群、追尾行为实现搜索寻优，觅食行为奠定了算法收敛的基础、聚群行为增强了算法收敛稳定性、追尾行为增强了算法收敛的快速性和全局性。同时人工鱼也会随机游动，使得算法可以跳出局部极值的领域。</p>
<p><img src="image-20200828061922951.png" alt="image-20200828061922951"></p>
<p>由于编码的性质，在算法进行之前还需要对得到的初始解群进行转换，确保各初始解中车辆序号相近，以保证后续算子交叉，趋近等行为的效率。(函数encode.m)</p>
<h4 id="参数和人工鱼类的设定">参数和人工鱼类的设定</h4>
<p>由于人工鱼类比较占用计算资源，因此算法中只设置了10条人工鱼，循环迭代30次进行求解。</p>
<p>人工鱼类有四个参数，即解方案route，按照前文所述编码得到的解，可以采取随机和采用初始解两种方法得到。视野范围visual使得人工鱼可以向附近的最优值靠拢，从而逃离局部极值，视野范围越大越容易发现全局极值并收敛；尝试次数try_num确保人工鱼可以随机游走，增加算法解的多样性；拥挤指数delta用来限制聚集规模，使得较优的地方可以聚集更多的人工鱼。（函数af.m）</p>
<p><img src="image-20200828061933873.png" alt="image-20200828061933873"></p>
<p><img src="image-20200828061949951.png" alt="image-20200828061949951"></p>
<h4 id="人工鱼的四种行为函数的设定">人工鱼的四种行为函数的设定</h4>
<p>觅食行为是人工鱼的一种基本行为，即在视野范围内，任选一点测试是否可以获得更优值，如果得到了比当前鱼所含解更优的解，则向该方向前进。在本部分中，将该行为简单的用自交叉行为代替，即选定任意位置开始的任意长度个解元素，和任意位置的相同长度个解元素进行交换。判断是否得到更优解。（函数prey.m）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-matlab" data-lang="matlab"><span style="color:#66d9ef">for</span>(i=<span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>af.try_num;i<span style="color:#f92672">++</span>){
  len = ceil(<span style="color:#ae81ff">20</span><span style="color:#f92672">*</span>rand());
  pos1 = ceil(<span style="color:#ae81ff">321</span><span style="color:#f92672">*</span>rand());
  pos2 = ceil(<span style="color:#ae81ff">321</span><span style="color:#f92672">*</span>rand()); 
	<span style="color:#f92672">//</span> 即随机生成位置<span style="color:#ae81ff">1</span>、<span style="color:#ae81ff">2</span>和长度
	temp_af = af;
  temp = af.route(pos1:pos1<span style="color:#f92672">+</span>len);
  temp_af.route(pos1:pos1<span style="color:#f92672">+</span>len) = af.route(pos2:pos2<span style="color:#f92672">+</span>len);
  temp_af.route(pos2:pos2<span style="color:#f92672">+</span>len) = temp;
	<span style="color:#66d9ef">if</span> (evaluate(temp_af) <span style="color:#f92672">&lt;</span> evaluate(af)){
 	af = temp_af;    
  }
}
<span style="color:#66d9ef">return</span> af;
</code></pre></div><p>聚群行为即鱼群自发的向某一点聚集，聚群行为并不需要领头者，而是整体会在个体局部的相互作用下呈现集群现象。在本部分中，认为当前鱼会探索视野范围内的伙伴数目及相对应的中心位置，如果该位置可以获取更优解且尚未饱和（不拥挤)则向该位置移动，同时需要说明的是距离计算采用相似度计算，及两个解之间的不同的元素的个数。（函数swarm.m）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-matlab" data-lang="matlab"><span style="color:#66d9ef">for</span> (i = <span style="color:#ae81ff">1</span>；i<span style="color:#f92672">&lt;</span>af_total; i<span style="color:#f92672">++</span>){
  <span style="color:#66d9ef">if</span> dstc(af,afs{i}) <span style="color:#f92672">&lt;</span> af.visual){
    n=n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
    temp =  afs{i}.route();
    <span style="color:#66d9ef">for</span> (j = <span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;</span>len_route;j<span style="color:#f92672">++</span>)
      route_center(j) = route_center(j) <span style="color:#f92672">+</span> temp(j); 
      <span style="color:#f92672">//</span>计算中心位置,求和
  }
}

<span style="color:#66d9ef">if</span> (n<span style="color:#f92672">~=</span><span style="color:#ae81ff">0</span>){
  <span style="color:#66d9ef">for</span> (i = <span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>len_route;i<span style="color:#f92672">++</span>)
    route_center(i) = round(route_center(i)<span style="color:#f92672">/</span>n);

<span style="color:#f92672">//</span>计算中心位置,求均值，得到中心位置
}

center = afs{<span style="color:#ae81ff">1</span>}.route;
<span style="color:#66d9ef">for</span>(i = <span style="color:#ae81ff">2</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>:af_total;i<span style="color:#f92672">++</span>){
  afs_route = afs{i}.route;
  out1 = <span style="color:#ae81ff">0</span>;
  out2 = <span style="color:#ae81ff">0</span>;
  <span style="color:#f92672">//</span> 依次比较每条鱼找到距离接近中心解的鱼
  <span style="color:#66d9ef">for</span> (j = <span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;</span>len_route;j<span style="color:#f92672">++</span>){
    out1 = out1 <span style="color:#f92672">+</span> sign(abs(center(j)<span style="color:#f92672">-</span>route_center(j)));
    out2 = out2 <span style="color:#f92672">+</span> sign(abs(afs_route(j)<span style="color:#f92672">-</span>route_center(j)));
  }
  <span style="color:#66d9ef">if</span> out2<span style="color:#f92672">&lt;</span>out1
    center = afs_route;
}

<span style="color:#f92672">//</span>如果拥挤度可以接受则将该解赋给当前鱼
<span style="color:#66d9ef">if</span> (evaluate(center)n <span style="color:#f92672">&gt;</span> evaluate(af) af.delta) <span style="color:#f92672">&amp;&amp;</span> (sum(center)！=sum(af.route))
  af.route = center;

<span style="color:#66d9ef">return</span> af

</code></pre></div><p>追尾行为即人工鱼会向得到较有解的人工鱼行进。和聚群行为实现方法类似，不过从跟踪平均最优值变为了跟踪视野范围内尚未饱和（不拥挤）的最优人工鱼。（函数follow.m）</p>
<p>随机游动比较简单，直接对任意解元素进行随机扰动，判断扰动后结果是否更优。(函数move.m)</p>
<h2 id="结果分析">结果分析</h2>
<p>​     鱼群算法中，设置人工鱼 10条，视野visual = 100 , 拥挤指数delta = 9, 尝试次数 try_num = 200，迭代次数为30时。</p>
<p>没有加入初始解时，路程为33970，空驶路程11792。</p>
<p>加入初始解后，路程为26094，其中空驶路程为3916。算法迭代图如下:</p>
<p><img src="image-20200828062015172.png" alt="image-20200828062015172"></p>
<p>同时尝试使用遗传算法，当种群规模为30，迭代次数为100，变异和交叉概率分别为0.3，0.7时。</p>
<p>没有加入初始解时，路程为32910，空驶路程为1973，违反了一次时间约束和两次四段约束。</p>
<p>​     加入初始解后，路程为28270，空驶路程为6273。</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>路程</th>
<th>空驶路程</th>
<th>违约数</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>鱼群算法（无初始解）</td>
<td>33970</td>
<td>11792</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>鱼群算法（有初始解）</td>
<td>26094</td>
<td>3916</td>
<td>0</td>
<td>对初始解敏感</td>
</tr>
<tr>
<td>遗传算法（无初始解）</td>
<td>32910</td>
<td>1973</td>
<td>w1=1，w3=2</td>
<td>容易得到不可行解</td>
</tr>
<tr>
<td>遗传算法（有初始解）</td>
<td>28270</td>
<td>6093</td>
<td>0</td>
<td>容易早熟</td>
</tr>
</tbody>
</table>
<p>最终得到的结果如下图所示：</p>
<p><img src="image-20200828062025038.png" alt="image-20200828062025038"></p>
<p>该算法性能较好，在没有初始可行解时也能很快收敛到一个可行解，在面对大规模问题且求解要求精度不高的情况下，具有良好的适用性。同时由于本次问题讨论中，约束条件和目标较少，存在一定的任务不均衡等情况，可以通过调整目标函数来进行进一步优化!</p>

    <h4><a href=""></a></h4>
</div>


        </div><footer class="container">
    <hr class="soften">
    <p>

    <a href="https://gitlab.com/maxlefou/hugo.386">theme by Max le Fou</a> | 

&copy; 
<a href="%20" target="_blank">
    cmc
</a>
<span id="thisyear">2020</span>

    | waiting


        |  <a href="//gohugo.io" target="_blank">Hugo</a>
</p>
    <p class="text-center">
        
        
        
        <a href="https://github.com/chengmingchun?tab=repositories">GitHub</a> 
        <a href="https://gitee.com/chengmingchun">Gitee</a>
    </p>
</footer>

</body><link rel="stylesheet" href="../css/bootstrap.css">
<link rel="stylesheet" href="../css/bootstrap-responsive.css">
<link rel="stylesheet" href="../css/style.css">

<script src="../js/jquery.js"></script>
<script src="../js/bootstrap-386.js"></script>
<script src="../js/bootstrap-transition.js"></script>
<script src="../js/bootstrap-alert.js"></script>
<script src="../js/bootstrap-modal.js"></script>
<script src="../js/bootstrap-dropdown.js"></script>
<script src="../js/bootstrap-scrollspy.js"></script>
<script src="../js/bootstrap-tab.js"></script>
<script src="../js/bootstrap-tooltip.js"></script>
<script src="../js/bootstrap-popover.js"></script>
<script src="../js/bootstrap-button.js"></script>
<script src="../js/bootstrap-collapse.js"></script>
<script src="../js/bootstrap-carousel.js"></script>
<script src="../js/bootstrap-typeahead.js"></script>
<script src="../js/bootstrap-affix.js"></script>
<script>
    _386 = { 
        fastLoad: false ,
        onePass: true , 
        speedFactor: 4 
    };

    
    function ThisYear() {
        document.getElementById('thisyear').innerHTML = new Date().getFullYear();
    };
</script></html>
