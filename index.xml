<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>神威空间</title>
    <link>/</link>
    <description>Recent content on 神威空间</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 28 Aug 2020 05:57:55 +0800</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>鱼群算法求解顺丰比赛问题</title>
      <link>/post/%E9%B1%BC%E7%BE%A4%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BB%84%E7%8E%AF%E9%97%AE%E9%A2%98.html</link>
      <pubDate>Fri, 28 Aug 2020 05:57:55 +0800</pubDate>
      
      <guid>/post/%E9%B1%BC%E7%BE%A4%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E7%BB%84%E7%8E%AF%E9%97%AE%E9%A2%98.html</guid>
      <description>本部分采取启发式算法进行求解探索，以期可以应对大规模问题的求解。最终得到较优解为26094，其中空驶路成为3916，最长行驶时间为41.08小时。在本部分中，主要采取禁忌搜索寻找初始可行解，再利用人工鱼群算法进行进一步的优化。
这是参加比赛时进行的算法设计，通过领域搜索和对鱼群算法框架的改动完成了集合覆盖类问题的求解。算法设计的重点在于编码设计，适应度函数设计和相应的算法动作的改造。鱼群算法因为杂揉了遗传算法的优胜劣汰、粒子群算法局部全域相结合以及领域搜索的随机性，具有较好的效果。
算法设计 编码设计 可以直接用实数编码的方式，即用数字代表车辆序号，比如4号任务数字为20，即20号车执行4号任务。同时为了加快算法的运行速度，引入顺序概念。比如4号任务的数字为20.4555代表20号车以0.4555的顺序执行该任务。
如果有一个原始码[5.432, 5.211, 4.221, 3.265, 3.710 &amp;hellip;&amp;hellip;]，解码后得到：
   车辆序号 执行任务     5 2-1   4 3   3 4-5    判断可行与否可以通过解码后将各车任务依次放入原数据中做对比，判断是否违反约束，在算法中，用w1,w3,w4分别表示违反时间约束，w3表示是否违反段数约束，w4表示是否违反运行时间约束。其中时间约束不仅判断当前是否可运行，同时对加入空驶和任务放入第二天是否可行都进行了判断。而地点衔接约束，可以通过空驶转换为前述三种约束。在判断函数中用w2记录空驶距离。（函数cando.m）
适应度函数则直接按照给解码后方案对应定数据表中的距离加上违反约束带来的惩罚和空驶距离来表示，当方案没有违反约束时，该适应度函数表示的是优化得到的距离。(函数foo.m)
初始解构造 初始解可以通过随机数的方式构造，这种方法的优点在于简单快捷，缺点在于会出现过多的不可行解，影响算法的精确度和运行速度；或者采取其他方法构造初始可行解群。这里简单介绍一下初始可行解的构造方法：
可以通过随机打乱1到341作为可行解种子（即每辆车只跑一个任务），然后对该解的每一部分进行随机扰动（由于编码的性质，可以很容易的证明车辆数会少于341，因此只减去一个随机因子便可以得到新解），如果得到的解更优的话，则保存新解。为了加强算法的搜索性能，引入了禁忌表作为辅助搜索策略，即更新解后会更新禁忌表相应的位置，保持该解一段时间。
pop = randperm(341); // 随机打乱1 - 341 best = inf; for(i =1; i&amp;lt;iter_time; i++ ){ copy = pop; if (tabu(i) &amp;lt; spec){ pop(i) = pop(i) - pop(i)rand(); if (evaluate(pop) &amp;lt; best)&amp;amp;&amp;amp;(cando(pop)){ best_pop = pop; best = evaluate(pop); tabu(i) = tl; //更新禁忌表，tl为禁忌步长 else pop = copy; //如果不符合约束或者没有更优则回退 } } //更新禁忌表 for(j = 1; j&amp;lt;length(tabu); j++){ if (tabu(j) &amp;gt; 0) tabu(j)--； } } 鱼群算法 鱼群算法是一种现代启发式智能搜索算法，具有现代优化算法的很多特征。通过模拟鱼群的觅食、聚群、追尾行为实现搜索寻优，觅食行为奠定了算法收敛的基础、聚群行为增强了算法收敛稳定性、追尾行为增强了算法收敛的快速性和全局性。同时人工鱼也会随机游动，使得算法可以跳出局部极值的领域。</description>
    </item>
    
    <item>
      <title>Js黑白棋</title>
      <link>/post/js%E9%BB%91%E7%99%BD%E6%A3%8B.html</link>
      <pubDate>Fri, 28 Aug 2020 05:53:03 +0800</pubDate>
      
      <guid>/post/js%E9%BB%91%E7%99%BD%E6%A3%8B.html</guid>
      <description>前几天做了个简单的杀病毒小游戏，发现js开发游戏具有很多优势，于是准备做一些游戏练练手。
 这次做的是个简单的黑白棋游戏，主要的交互方法是通过鼠标事件监听实现的。
canvas对象里支持所有的js鼠标事件，包括单击(MouseClick)、按下(MouseDown)、抬起(MouseUp)、移动(MouseMove)
其添加方法基本和在文件里添加没啥区别
canvas,addEventListener(`mousedown`,domousedown , false) //另有反模式 canvas.onmousedown = function(e){} 游戏思路很简单，就是利用鼠标监听事件来完成游戏的进程推进，一旦监听道鼠标事件，就进行坐标转换，将坐标转换为canvas内的坐标，再转换为棋盘上的点，对该点进行检查和方向上棋子的变换后，再对棋盘上所有的点进行标记，根据不同的标记绘制不同的图案，这样就完成了整个游戏的逻辑。
首先定义black，white，empty等标记。创立囊括整个棋盘的矩阵，在网页窗体初始化的时候运行init函数来进行初始化。
function init(){ initLevel(); //初始化开始的棋子  showMoveInfo(); //显示现在的棋局信息到公示板  Canvas,addEventListener(“mousedown”, doMouseDown,false); } 初始化棋子主要是在放下启始的四颗棋子，而信息公示版主要用innerHTML实现就可以了。
这样就完成了初始化的工作，接下来完成几个重要功能，首先是响应鼠标事件，响应鼠标事件要完成对鼠标坐标的转换，对落子点的标记变换。以及后续的检查，变换等一系列功能。
对于坐标的转换这里是通过getBoundingClientRect()属性来实现的：
function getPointOnCanvas(canvas,x,y){ var box = canvas.getBoundingClientRect(); return {x: x - box.left*(canvas.width/box.width), y: y - box.top*(canvas.height/box.height)} } function clickStone( loc ){ var x = Math.round((loc.x-40)/80) ; var y = Math.round((loc.y-40)/80); } 接着比较重要的功能是判断选中的坐标是否可以落子，其思路是通过判断上下左右八个方向是否有对方的棋子来实现的。
//判断上下左右等八个方向可否落子 function can_go(x,y){ if(checkDirect(x,y,-1,0)){ return true; } if(checkDirect(x,y,-1,-1)){ return true; } if(checkDirect(x,y,1,0)){ return true; } if(checkDirect(x,y,1,1)){ return true; } if(checkDirect(x,y,0,-1)){ return true; } if(checkDirect(x,y,1,1)){ return true; } if(checkDirect(x,y,0,1)){ return true; } if(checkDirect(x,y,-1,1)){ return true; } return false; } function checkDirect(x,y,dx,dy){ var flag = false x = x+dx; y = y+dy; while(InBoard(x,y)&amp;amp;&amp;amp;!</description>
    </item>
    
    <item>
      <title>About_yesterday</title>
      <link>/post/about_yesterday.html</link>
      <pubDate>Thu, 27 Aug 2020 22:15:51 +0800</pubDate>
      
      <guid>/post/about_yesterday.html</guid>
      <description>I chose this essay as my topic, because it&amp;rsquo;s just too charming for me , the author is so familiar to the words that he can easily make his memory emerge into my sight with vivid and subtle sentences.
As to the questions casted, my answer and analysis will orient towards directions as follows: 1. the landscape plainly implicate the changes caused by time. 2. the landscape also reinforce the fine sentiment beneath the prosaic words.</description>
    </item>
    
    <item>
      <title>仓储论</title>
      <link>/post/%E4%BB%93%E5%82%A8%E8%AE%BA.html</link>
      <pubDate>Thu, 27 Aug 2020 22:12:13 +0800</pubDate>
      
      <guid>/post/%E4%BB%93%E5%82%A8%E8%AE%BA.html</guid>
      <description>将存储过程看作一个系统。里面的要素有时间（t）、需求（D）、成本（固定成本A，生产成本c，持有库存成本h）和库存订单（Q）。其中的输入变量是需求，变量是时间和成本，而输出变量是订单。
即如何在给定的时间和成本条件下，满足需求且成本最小化。
一般来说，库存模型分为确定且平稳，确定且随时间变化；随机且平稳，随机且随时间变化。(区分标准分别是平均数$\overline x$，变异系数$V$)
确定型存储论模型 带折扣的EOQ模型 分段价格的EOQ模型也叫带折扣的EOQ模型，当订货数量y超过某个给定上限q时，库存货物可以按照折扣购买。即： $$ \begin{cases}c_1,若y\leq q ;\ c_2,若y&amp;gt;q\end{cases},c_1&amp;gt;c_2 $$ 通过标准模型可以得到每单位的采购费用
增量折扣 增量折扣本质上和全量折扣差不多，但是在公式计算时用的是可变单位成本，很好理解，因为跨区间时，每单位的成本时不一样的。计算如下 $$ c_i = \frac{b_1 c_1+(b2-b1)c_2+&amp;hellip;(Q-b_n)c_n}{Q} $$
其具体推导过程如下图示：
动态价格的EOQ模型 这种情况下，为了满足某一周期的需求，我们只能通过用库存去满足，或者用生产去满足
动态规划方法 一般不用动态规划的方法，写起来太麻烦了，转而采用Wagner-Whitin方法，在随机型库存时会更多的介绍原生动态规划方法。
Wagner-Whitin方法  Wagner-Whitin是一种简化后的动态规划方法，描述起来说是横向广度的
 按照动态规划的思想就是算每一个周期的成本，包括本周期生产的成本，上一周期生产本周期的成本、上上周期生产的成本&amp;hellip;.然后取其小者作为生产策略，并作为总体策略的一部分对下一周期产生影响。
计算公式则和标准EOQ类似 $$ c_iD_i+A_i+Z_{i-1}^* $$ 以$Z_3$为例(注意，这里举例用的单位生产成本是固定的)，计算应该是
$$ Z_3^* = min \begin{cases} A_1+h_1D_2+(h_1+h_2)D_3; \ Z_1^*+A_2+h_2D_3; \ Z_2^*+A_3\end{cases} $$
给出一道例题的计算如下
Slive-Meal方法  Slive-Meal是一种启发式的算法，这种算法得到的答案可能是非最优的，描述起来说是横向深度的。
 使用这种方法有一个要求：每个周期的单位生产成本是相同的，即单位生产成本是稳态的。
这种方法和前面的方法思路上差不多，不过计算的是平均成本。
计算方法是从第一周期开始计算生产本周，生产下一个周期，下下个周期的单位生产成本&amp;hellip;..直到出现局部最小成本点，然后从局部最小点后一周期再开始循环。
具体计算公式有 $$ J_1 = min{\frac{A_1}{D_1},\frac{A_1+h_1D_2}{D_1+D_2},\frac{A_1+h_1(D_2+D_3)+h_2D_3}{D_1+D_2+D_3}&amp;hellip;} $$ 或者 $$ J_1 = min{\frac{A_1}{1}+\frac{A_1+h_1D_2}{2}+\frac{A_1+h_1(D_2+D_3)+h_2D_3}{3}&amp;hellip;} $$
 注意这种方法是对第一个式子的极限逼近，更加草率了点</description>
    </item>
    
    <item>
      <title>Lingo上手攻略</title>
      <link>/post/lingo%E4%B8%8A%E6%89%8B%E6%94%BB%E7%95%A5.html</link>
      <pubDate>Thu, 27 Aug 2020 22:10:55 +0800</pubDate>
      
      <guid>/post/lingo%E4%B8%8A%E6%89%8B%E6%94%BB%E7%95%A5.html</guid>
      <description>Lingo速上手攻略 [toc]
核心思想 lingo引入了集合（set）概念，集合是这一组相关的对象构成的组合，代表模型中的实际事物。集合的事先声明包括集合的名称、集合的要素、集合的属性，形如WH/W1..W6/:AI
多个基本集合可以通过Links(WH,VD):C,X的方式组成一个衍生集合，衍生集合如果没有指定衍生的成员，将会取所有可能的组合
lingo中数据段的定义是通过DATA: ENDDATA来实现一直变量的赋值的。
基本语法 @sum(s:e)求和函数，括号里面填写求和的集合名称（表示对这些成员进行）和表达式（表示对该表达式进行），以:做分割。如果参与运算的属性来自同一个集合，则索引符号可以省略。
@for(s:e)循环函数,括号填写同上。如果参与运算的属性来自同一个集合，则索引符号可以省略。
@size(s) 返回成员个数
@warp(I,N) 返回在I&amp;ndash;N之间的数，(如果I$\gt$ N则返回 I-N*K , $\forall$ K)
@index(s:ek) 返回ek元素在s中的顺序号
常用功能 实例  okay,来看一个实例   首先建立模型，$min Z=\sum\sum c_{ij} x_{ij}$于是有 $s.t. \begin{cases}\sum x_{ij}&amp;lt; a_i,i=1&amp;hellip;6\ \sum_{i =1}^6 x_{ij} = d_{j}\ x_{ij}&amp;gt; 0\end{cases}$在lingo中求解如下MODEL: SETS: WH/W1..W6/:AI; VD/V1..V8/:DJ; LINKS(WH,VD):C,X; ENDSETS DATA: AI = 60,55,51,43,41,52; DJ = 35,37,22,32,41,32,43,28; C = 6,2,6,7,4,2,5,9 4,9,5,3,8,5,8,2 5,2,1,9,7,4,3,3 7,6,7,3,9,2,7,1 2,3,9,5,7,2,6,5 5,5,2,2,8,1,4,3; ENDDATA MIN=@SUM(LINKS(I,J):C(I,J)*X(I,J)); ！@SUM(LINKS:C*X); @FOR(WH(I):@SUM(VD(J):X(I,J))&amp;lt;=AI(I)); @FOR(VD(J):@SUM(WH(I):X(I,J))= DJ(J)); END 周一到周日安排x(i)个人上班，周一上班的人周六周日肯定在休息，以此类推，即周一除了周二和周三开始上班的人都在上班&amp;hellip;</description>
    </item>
    
    <item>
      <title>实习小结</title>
      <link>/post/%E5%AE%9E%E4%B9%A0%E5%B0%8F%E7%BB%93.html</link>
      <pubDate>Thu, 27 Aug 2020 17:01:03 +0800</pubDate>
      
      <guid>/post/%E5%AE%9E%E4%B9%A0%E5%B0%8F%E7%BB%93.html</guid>
      <description>Promise 主要解决回调地狱，状态pending resolved rejected
const newPromise = new Promise((resolve,reject) =&amp;gt; { //pending阶段要做的事，同步执行  //判断如何通向resovle或reject状态，从而异步执行resovle(data)或reject(error) }); newPromise.then( (data) =&amp;gt; { 当newPromise的状态变成fulfilled后，该函数立即执行 这里写通向fulfilled状态后要做的事情 }, (error) =&amp;gt; { 当newPromise的状态变成rejected后，该函数立即执行 这里写通向rejected状态后要做的事情 } ); async 位于函数字面量或函数表达式的前面，被修饰函数执行后会返回一个promise对象
async function chloe(){ console.log(&amp;#39;chloe&amp;#39;); return 20; } // ======== 等价于 function chloe(){ return new Promise((resolve,reject)=&amp;gt;{ console.log(&amp;#39;chole&amp;#39;); resolve(20); }) } await 位于async函数内部，一般位于promise对象之前，会拿到该对象的结果，即resolve 和 reject的参数，如果不是promise对象则会用Promise.resolve包装后返回对应的值。会强制等待至拿到结果
async function chloe(){ console.log(&amp;#39;chloe&amp;#39;); return 20; } async function taran(){ //chole函数执行并返回一个Promise对象，await拿到其resolve参数20  const age = await chloe(); console.</description>
    </item>
    
    <item>
      <title>博客说明</title>
      <link>/post/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E.html</link>
      <pubDate>Thu, 27 Aug 2020 15:32:46 +0800</pubDate>
      
      <guid>/post/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E.html</guid>
      <description>上次学生机到期后，发现有个博客真香，加上自己接触了新的框架知识，想着自己从头写一个博客系统，结果意外发现这个很好玩的博客主题，于是目标成了在这个主题的基础上做一些其他的网页来完善它，同时可以记录自己未来学习生活遇到的问题和产生的新的想法。
目前只针对样式进行了一些改观，把原来刺眼的和看起来不太舒服的样式表都改掉了
接下来需要完成的东西有
  以前博客文章的整理再上传
  照片墙，记录自己用单反拍的照片之类的，打算用vue和element-ui 进行设计
  侧边栏，仿照老式qq设计一个好康的侧边栏
  leetcode的题解
  一些静态页面的部署（因为使用giteepages托管的）
  </description>
    </item>
    
  </channel>
</rss>